<!DOCTYPE html>
<meta charset="utf-8">
<style>

.background {
  fill: none;
  stroke: #e4e5eb;
  pointer-events: all;
}

#map{
    position: absolute;
    top: 13vh;
    left: 25vw;
    width: 70vw;
    height: 70vh;
}

#toggles{
    position: absolute;
    top: 13vh;
    left: 5vw;
    fill: black;
    width: 15vw;
    height: 25vh;
}

#timeline{
    position: absolute;
    top: 87vh;
    left: 4.5vw;
    fill: white;
    stroke: black;
    width: 100vw;
    height:20vh;
}

</style>
<body>
<!-- Load d3.js -->
<script src="js/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<!-- Create an element where the map will take place -->
<h1></h1></br>
<svg id="map"></svg>
<svg id="toggles"></svg>
<svg id="vis"></svg>
<svg id="timeline"></svg>
<script>

window.onresize = function(){ ready(); }

// Title, centered
var title = d3.select("h1")
    .text("Bloop")
    .style("text-align", "center")
    .style("font-family", "optima");

// The svg for map
var svg = d3.select("#map"),
  width = +svg.node().getBoundingClientRect().width,
  height = +svg.node().getBoundingClientRect().height;

// Background for map
svg.append("rect")
      .attr("class", "background")
      .attr("width", svg.node().getBoundingClientRect().width)
      .attr("height", svg.node().getBoundingClientRect().height);

// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
  .scale(95)
  .center([0,40])
  .translate([svg.node().getBoundingClientRect().width / 2, svg.node().getBoundingClientRect().height / 2]);

// Enable map zoom
var zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", zoomed);
var g = svg.append("g");
svg.call(zoom);

// Data and color scale
var gainData = d3.map();
var ghgData = d3.map();
var perCapGhgData = d3.map();
var gainColorScale;
var ghgColorScale;
var perCapGhgColorScale;

/*Color Constants
Original Colors
const BOTTOM_LEFT = "#5ca166"; //Green
const TOP_LEFT = "#f0e784"; //Yellow
const BOTTOM_RIGHT = "#80c7ed"; //Blue
const TOP_RIGHT = "#992e2e"; //Red
const NO_DATA = "lightgrey";*/

/*Potential alternative, makes low risk high emissions red
const BOTTOM_LEFT = "#80c7ed"; //Blue
const TOP_LEFT = "#992e2e"; //Red
const BOTTOM_RIGHT = "#f0e784"; //Yellow
const TOP_RIGHT = "#5ca166"; //Green
const NO_DATA = "lightgrey";*/

//Potential alternative, maintains property from above but makes it so that high risk high emissions isn't green
const BOTTOM_LEFT = "#80c7ed"; //Blue
const TOP_LEFT = "#992e2e"; //Red
const BOTTOM_RIGHT = "#ff7000" //Orange
const TOP_RIGHT = "#ffeb13"; //More Vibrant Yellow
const NO_DATA = "lightgrey";

/*Potential alternative adapted from https://colorbrewer2.org/#type=diverging&scheme=PRGn&n=11
const BOTTOM_LEFT = "grey"; //Grey
const TOP_LEFT = "#40004b"; //Purple
const BOTTOM_RIGHT = "#00441b" //Green
const TOP_RIGHT = "#000000"; //Black
const NO_DATA = "lightgrey";*/

/*Potential alternative adapted from https://colorbrewer2.org/#type=diverging&scheme=BrBG&n=7
const BOTTOM_LEFT = "#b1b1b1"; //Grey
const TOP_LEFT = "#8c510a"; //Brown
const BOTTOM_RIGHT = "#01665e" //Teal
const TOP_RIGHT = "#000000"; //Black
const NO_DATA = "white";*/


//Set up initial state
loadData(2016);
const DisplayType = {
   EMISSIONS: 1,
   GAIN: 2,
   COMBO: 3
};
var display = DisplayType.COMBO;

// Load external data and boot
function loadData(year) {
  d3.queue()
  .defer(d3.json, "js/world.geojson")
  .defer(d3.csv, "ND_GAIN_Data/gain/gain.csv", function(d) {  gainData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "Emissions_Data/Emissions_with_ISO3.csv", function(d) { ghgData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "Emissions_Data/emissions_per_cap_no_nans.csv", function(d) {perCapGhgData.set(d.ISO3, +d[year]); })
  .await(ready);
}


function set_up_color_scales() {
  gainColorScale = d3.scaleLinear()
              .domain([20, 76])
              //Right to Left because GAIN index is backwards from risk
              .range([BOTTOM_RIGHT, BOTTOM_LEFT]);
  ghgColorScale =  d3.scaleLinear()
              .domain([-100, 12000])
              .range([BOTTOM_LEFT, TOP_LEFT]);
  perCapGhgColorScale = d3.scaleLinear()
              .domain([0, 35])
              .range([BOTTOM_LEFT, TOP_LEFT]);
}
function ready(error, topo) {
  var projection = d3.geoMercator()
                    .scale(95)
                    .center([0,40])
                    .translate([svg.node().getBoundingClientRect().width / 2, 
                                svg.node().getBoundingClientRect().height / 2]);
  // Background
  svg.select("rect")
      .attr("width", svg.node().getBoundingClientRect().width)
      .attr("height", svg.node().getBoundingClientRect().height);

  // Draw the map
    g.selectAll("path")
    .data(topo.features)
    .enter()
    .append("path")
      // draw each country
      .attr("d", d3.geoPath()
        .projection(projection)
      )
      .on('click', displayVals)
      .style("stroke", "gray")
      .style("stroke-width", .25)
      // set the color of each country
      set_up_color_scales();
      reload_map();
}
// Function to get Country Values
function displayVals(d, i){
  if (display == 1){
          ghgVal = ghgData.get(d.id)
          if (typeof ghgVal == 'undefined') {
            return NO_DATA;
          } else {
            console.log(ghgVal);
          }
        }
        else if (display == 2){
          if (typeof gainData.get(d.id) == 'undefined') {
            return NO_DATA;
          } else {
            console.log(gainData.get(d.id));
          }
        }
        else {
          gainVal = gainData.get(d.id)
          if (typeof gainVal == 'undefined') {
            return NO_DATA;
          } else {
            console.log(gainVal);
          }
          ghgVal = ghgData.get(d.id)
          if (typeof ghgVal == 'undefined') {
            return NO_DATA;
          } else {
            console.log(ghgVal);
          }
        }
}
// Draw four rectangles and labels for matrix key
svg.append("rect")
    .attr("id", "Min_Each")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 28)
    .attr("y", svg.node().getBoundingClientRect().height *.895)
    .attr("fill", BOTTOM_LEFT)
svg.append("rect")
    .attr("id", "Max_Risk")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 53)
    .attr("y", svg.node().getBoundingClientRect().height *.895)
    .attr("fill", BOTTOM_RIGHT);
svg.append("rect")
    .attr("id", "Max_Emissions")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 28)
    .attr("y", svg.node().getBoundingClientRect().height *.837)
    .attr("fill", TOP_LEFT);
svg.append("rect")
    .attr("id", "Max_Combo")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 53)
    .attr("y", svg.node().getBoundingClientRect().height *.837)
    .attr("fill", TOP_RIGHT);
svg.append("text")
	.style("fill", "black")
	.style("font-family", "optima")
    .style("font-size", "11px")
    .attr("y", 18)
    .attr("x", 0 - svg.node().getBoundingClientRect().height *.945)
    .attr("text-anchor", "left")
    .attr("transform", "rotate(270)")
    .text("Emissions ->");
svg.append("text")
	.style("fill", "black")
	.style("font-family", "optima")
    .style("font-size", "11px")
    .attr("x", 28)
    .attr("y", svg.node().getBoundingClientRect().height *.98)
    .attr("text-anchor", "left")
    .text("Risk Index ->");
svg.append("rect")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 40)
    .attr("y", svg.node().getBoundingClientRect().height *.70)
    .attr("fill", NO_DATA)
    .style("stroke", NO_DATA)
    .style("stroke-width", 1);
svg.append("text")
  .style("fill", "black")
  .style("font-family", "optima")
    .style("font-size", "11px")
    .attr("x", 51.5)
    .attr("y", svg.node().getBoundingClientRect().height *.79)
    .attr("text-anchor", "middle")
    .text("No Data");

var timeline_array = [
  {cx: 0, cy: 15, r: 8},
  {cx: 1, cy: 15, r: 8},
  {cx: 2, cy: 15, r: 8},
  {cx: 3, cy: 15, r: 8},
  {cx: 4, cy: 15, r: 8},
  {cx: 5, cy: 15, r: 8},
  {cx: 6, cy: 15, r: 8},
  {cx: 7, cy: 15, r: 8},
  {cx: 8, cy: 15, r: 8},
  {cx: 9, cy: 15, r: 8},
  {cx: 10, cy: 15, r: 8},
  {cx: 11, cy: 15, r: 8},
  {cx: 12, cy: 15, r: 8},
  {cx: 13, cy: 15, r: 8},
  {cx: 14, cy: 15, r: 8},
  {cx: 15, cy: 15, r: 8},
  {cx: 16, cy: 15, r: 8},
  {cx: 17, cy: 15, r: 8},
  {cx: 18, cy: 15, r: 8},
  {cx: 19, cy: 15, r: 8},
  {cx: 20, cy: 15, r: 8},
  {cx: 21, cy: 15, r: 8},

];
// Draw timeline for time series data. TO DO:
// Simple for loop to add 18 circles representing 1995-2012
// Add labels to circles
// Make circles clickable
// Highlight circle on mouseover
var timeline_svg = d3.select("#timeline"),
  width = +timeline_svg.node().getBoundingClientRect().width,
  height = +timeline_svg.node().getBoundingClientRect().height;
var timeline = d3.select("#timeline")
	.append("line")
	.attr("x1", 20)
	.attr("y1", 15)
	.attr("x2", timeline_svg.node().getBoundingClientRect().width - 90)
	.attr("y2", 15)
	.attr("stroke-width", 1.5)
	.attr("stroke", "black");

var cur_year = 2016;
var year_line = [];
var gap = (timeline_svg.node().getBoundingClientRect().width - 110)/21;
var circles = timeline_svg.selectAll('circle')
                .data(timeline_array)
                .enter()
                .append('circle')
                  .attr('cx', function(d){
                    return (d.cx * gap + 12);
                  })
                  .attr('cy', function(d){
                    return (d.cy);
                  })
                  .attr('r', function(d){
                    return (d.r);
                  })
                  .attr("stroke-width", 1)
                  .on('mouseover', handleMouseOver)
                  .on('mouseout', handleMouseOut)
                  .on('click', handleMouseClick);

var text = timeline_svg.selectAll("text")
                    .data(timeline_array)
                    .enter()
                    .append("text");
var textLabels = text
            .attr('x', function(d) {return d.cx * gap -2})
            .attr('y',40)
            .text( function (d, i) { return String(i + 1995); })
            .attr("font-family", "monospace")
            .attr("font-size", "12px")
            .attr("fill", "#215722");

function highlightYear(selection) { selection.attr("fill", "gray"); 
                                    selection.attr("stroke", "gray"); }
function unhighlightYear(selection) { selection.attr("fill", "white"); 
                                      selection.attr("stroke", "black"); }

function handleMouseOver(d, i){
  // Use D3 to select element, change color
  d3.select(this).call(highlightYear);
}

function handleMouseClick(d, i){
  // Reset previously clicked circle
  timeline_svg.selectAll('circle').on("mouseout", handleMouseOut);
  timeline_svg.selectAll('circle').on("mouseover", handleMouseOver);
  timeline_svg.selectAll('circle').call(unhighlightYear);

  // Use D3 to select element, change color of this circle
  d3.select(this).attr("fill", "black");
  d3.select(this).on("mouseout", null);
  d3.select(this).on("mouseover", null);

  // Specify where to put label of text
  var year = d.cx + 1995;
  cur_year = year;
  loadData(year);
}

function handleMouseOut(d, i) {
  // Use D3 to select element, change color back to normal
  d3.select(this).call(unhighlightYear);
}

var button_svg = d3.select('#toggles'),
    width = +button_svg.node().getBoundingClientRect().width,
    height = +button_svg.node().getBoundingClientRect().height;

var per_capita_box = "<input type='checkbox' id='per_capita' name='per_capita' value='per_capita' onclick='reload_map();'> <label for='per_capita'>Per capita</label><br>"


var emissions = "<input type='button' onclick='dispEmissions()' id='emissions' name='emissions' value='Emissions'><br>"
var risk = "<input type='button' onclick='dispGain()' id='gain' name='gain' value='Risk'><br>"
var combination = "<input type='button' onclick='dispCombo()' id='combo' name='combo' value='Combination Matrix'> <br>"

button_svg.append("text")
    .attr("text-anchor", "middle")
    .attr("x", button_svg.node().getBoundingClientRect().width * .50)
    .attr("y", button_svg.node().getBoundingClientRect().height * .1)
    .style("font-family", "optima")
    .text("Map Displays:");

button_svg.append("foreignObject")
    .attr("width", 70)
    .attr("height", 30)
    .attr("x", button_svg.node().getBoundingClientRect().width * 0)
    .attr("y", button_svg.node().getBoundingClientRect().height * .25)
    .append("xhtml:div")
    .style("font", "14px 'Helvetica Neue'")
    .html(emissions);

// Emissions help button
// MARGO STILL NEEDS TO FINISH THIS SUNDAY
button_svg.append("circle")
    .attr("cx", button_svg.node().getBoundingClientRect().width * .45)
    .attr("cy", button_svg.node().getBoundingClientRect().height * .305)
    .attr("r", 8)
    .attr("stroke-width","0px")
    .attr("fill", "lightgray");
button_svg.append("text")
    .attr("x", button_svg.node().getBoundingClientRect().width * .435)
    .attr("y", button_svg.node().getBoundingClientRect().height * .33)
    //.attr("dx", function(d){return -20})
    .style("font-size", "11px")
    .attr("fill", "white")
    .text("?");

// Create Gain help button
// MARGO STILL NEEDS TO FINISH THIS SUNDAY

button_svg.append("foreignObject")
    .attr("width", 60)
    .attr("height", 30)
    .attr("x", button_svg.node().getBoundingClientRect().width * 0)
    .attr("y", button_svg.node().getBoundingClientRect().height * .45)
    .append("xhtml:div")
    .style("font", "14px 'Helvetica Neue'")
    .html(risk);

// Create Combination Matrix help button
// MARGO STILL NEEDS TO FINISH THIS SUNDAY

button_svg.append("foreignObject")
    .attr("width", 120)
    .attr("height", 30)
    .attr("x", button_svg.node().getBoundingClientRect().width * 0)
    .attr("y", button_svg.node().getBoundingClientRect().height * .65)
    .append("xhtml:div")
    .style("font", "14px 'Helvetica Neue'")
    .html(combination);

button_svg.append("foreignObject")
    .attr("width", 300)
    .attr("height", 100)
    .attr("y", button_svg.node().getBoundingClientRect().height * .9)
  .append("xhtml:div")
    .style("font", "14px 'Helvetica Neue'")
    .html(per_capita_box);


//Experimenting with info window
/*var info_window_svg = d3.select("#vis")
    width = +info_window_svg.node().getBoundingClientRect().width,
    height = +info_window_svg.node().getBoundingClientRect().height;


info_window_svg.append("rect")
  .attr("class", "background")
  .attr("fill", "gray")
  .attr("width", 200)
  .attr("height", 400)*/
  // Zoom map upon mouse zoom
function zoomed() {
  g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  g.attr("transform", d3.event.transform);
}

function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

function average(array) {
  return array.reduce((a, b) => a + b) / array.length;
}

function fillCountryColor() {
  displayPerCap = document.getElementById("per_capita").checked;
  var ghgMidpoint = average(ghgData.values());
  var gainMidpoint = average(gainData.values());
  var perCapMidpoint = average(perCapGhgData.values());
  g.selectAll("path")
    .attr("fill", function (d) {

          ghgVal = ghgData.get(d.id);
          gainVal = gainData.get(d.id);
          perCapGhgVal = perCapGhgData.get(d.id);
          ghgDisplayVal = displayPerCap ? perCapGhgVal : ghgVal; 

          ghgDisplayMidpoint = displayPerCap ? perCapMidpoint : ghgMidpoint

          if (typeof ghgDisplayVal == 'undefined' || typeof gainVal == 'undefined') {
            return NO_DATA;
          } else if (ghgDisplayVal <= ghgDisplayMidpoint && gainVal >= gainMidpoint) {
            return BOTTOM_LEFT;
          } else if (ghgDisplayVal > ghgDisplayMidpoint && gainVal >= gainMidpoint) {
            return TOP_LEFT;
          } else if (ghgDisplayVal <= ghgDisplayMidpoint && gainVal < gainMidpoint) {
            return BOTTOM_RIGHT;
          } else if (ghgDisplayVal > ghgDisplayMidpoint && gainVal < gainMidpoint) {
            return TOP_RIGHT;
          } else {
            return "black";
          }
        })
}
function fillGainColor() {
  var gainMidpoint = average(gainData.values());
  g.selectAll("path")
    .attr("fill", function (d) {
          if (typeof gainData.get(d.id) == 'undefined') {
            return NO_DATA;
          } else {
            return gainColorScale(gainData.get(d.id));
          }
        })
}
function fillEmissionsColor() {
  displayPerCap = document.getElementById("per_capita").checked 
  g.selectAll("path")
    .attr("fill", function (d) {
          ghgVal = ghgData.get(d.id);
          perCapGhgVal = perCapGhgData.get(d.id);
          ghgDisplayVal = displayPerCap ? perCapGhgVal : ghgVal ;
          ghgDisplayColorScale = displayPerCap ? perCapGhgColorScale : ghgColorScale;
          if (typeof ghgDisplayVal == 'undefined') {
            return NO_DATA;
          } else {
            return ghgDisplayColorScale(ghgDisplayVal);
          }
        })
}


function dispGain(){
    display = DisplayType.GAIN;
    var maxRisk = d3.select('#Max_Risk')
                  .attr('opacity', 100)
    var maxCombo = d3.select('#Max_Combo')
                  .attr('opacity', 0)
    var maxEmissions = d3.select('#Max_Emissions')
                          .attr('opacity', 0)
    reload_map();
}
function dispEmissions(){
    display = DisplayType.EMISSIONS;
    var maxRisk = d3.select('#Max_Risk')
                  .attr('opacity', 0)
    var maxCombo = d3.select('#Max_Combo')
                  .attr('opacity', 0)
    var maxEmissions = d3.select('#Max_Emissions')
                          .attr('opacity', 100)
    reload_map();
}

function dispCombo(){
    display = DisplayType.COMBO;
    var maxRisk = d3.select('#Max_Risk')
                  .attr('opacity', 100)
    var maxCombo = d3.select('#Max_Combo')
                  .attr('opacity', 100)
    var maxEmissions = d3.select('#Max_Emissions')
                          .attr('opacity', 100)
    reload_map();
}

function reload_map() {
    switch (display) {
      case DisplayType.EMISSIONS:
        fillEmissionsColor();
        break;
      case DisplayType.GAIN:
        fillGainColor();
        break;
      case DisplayType.COMBO:
        fillCountryColor()
    }
}


// Determine color of country
function valuesToColor(ghgVal, gainVal) {
  // Specific to 2016 though... 

}

</script>
</body>








