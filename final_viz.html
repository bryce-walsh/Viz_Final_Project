<!DOCTYPE html>
<meta charset="utf-8">
<style>

/* SLIDER START */
#chart {
  position: absolute;
  top: 88vh;
  left: 4.5vw;
  width: 100vw;
  height: 10vh;
}

#chart line.track {
  stroke: black;
  stroke-width: 7px;
}

#chart line.track-inset {
  stroke: steelblue;
  stroke-width: 8px;
}
#chart line.track-overlay {
  stroke: white;
  stroke-width: 40px;
  stroke-opacity: 0;
  cursor: pointer;
}
#chart .handle {
  fill: white;
  stroke: black;
  stroke-width: 1.5px;
}
/* SLIDER END */

body {
  margin-bottom: none;
  margin-top: 20px
}

h1 {
  margin: 5px;
}

h3 {
  font-weight: normal;
  margin: 0;
}

div.tooltip-donut {
     position: absolute;
     text-align: center;
     padding-left: 15px;
     padding-right: 15px;
     background: white;
     color: black;
     border: 1px solid black;
     border-radius: 8px;
     pointer-events: none;
     font-size: 12px;
}

.background {
  fill: none;
  stroke: #e4e5eb;
  pointer-events: all;
}

.toggles_background {
  fill: none;
  pointer-events: all;
}

.button rect {
  fill: darkgrey;
  border: none;
  color: white;
  padding: 4px 10px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  margin: 4px 2px;
  cursor: pointer;
}

.button:hover rect{
  fill: lightgray;
  border: none;
  color: white;
  padding: 4px 10px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  margin: 4px 2px;
  cursor: pointer;
}

.button text {
  fill: white;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-family: optima;
  font-size: 12px;
  cursor: pointer;
}

.button:hover text{
  fill: white;
  border: none;
  color: white;
  padding: 4px 10px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  margin: 4px 2px;
  cursor: pointer;
}

.button_checked rect {
  fill: darkgrey;
  border: 1px;
  stroke: white;
  color: white;
  padding: 4px 10px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  margin: 4px 2px;
  cursor: pointer;
}

.button_checked text {
  fill: white;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-family: optima;
  font-size: 10px;
  cursor: pointer;
}

.button_unchecked rect {
  fill: white;
  border: 1px;
  stroke: white;
  color: white;
  padding: 4px 10px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  margin: 4px 2px;
  cursor: pointer;
}

.button_unchecked text {
  fill: darkgrey;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-family: optima;
  font-size: 10px;
  cursor: pointer;
}

#map{
    position: absolute;
    top: 18vh;
    left: 25vw;
    width: 70vw;
    height: 65vh;
}

#toggles{
    position: absolute;
    top: 17vh;
    left: 5vw;
    fill: black;
    width: 15vw;
    height: 30vh;
}

#infowindow{
    position: absolute;
    top: 53vh;
    left: 5vw;
    width: 20vw;
    height: 25vh;
} 


</style>
<body>
<!-- Load d3.js -->
<script src="js/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<!-- Create an element where the map will take place -->
<h1></h1><h3></h3></br>
<svg id="map"></svg>
<svg id="toggles"></svg>
<svg id="infowindow"></svg>
<svg id="chart"></svg>
<svg id="barchart"></svg>

<script>

window.onresize = function(){ ready(); }

// Title, centered
var title = d3.select("h1")
    .text("Environmental Impact by Country")
    .style("text-align", "center")
    .style("font-weight", "bold")
    .style("font-family", "optima");

var subtitle = d3.select("h3")
    .text("And the mismatch between emissions and climate change afflictions")
    .style("text-align", "center")
    .style("font-family", "optima");

// The svg for map
var svg = d3.select("#map"),
  width = +svg.node().getBoundingClientRect().width,
  height = +svg.node().getBoundingClientRect().height;

// Background for map
svg.append("rect")
      .attr("class", "background")
      .attr("width", svg.node().getBoundingClientRect().width)
      .attr("height", svg.node().getBoundingClientRect().height);

// Enable map zoom
var zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", zoomed);
var g = svg.append("g");
svg.call(zoom);

// Data and color scale
var gainData = d3.map();
var ghgData = d3.map();
var perCapGhgData = d3.map();
var gainRankData = d3.map();
var ghgRankData = d3.map();
var perCapGhgRankData = d3.map();
var gainColorScale;
var ghgColorScale;
var perCapGhgColorScale;

/*Color Constants
Original Colors
const BOTTOM_LEFT = "#5ca166"; //Green
const TOP_LEFT = "#f0e784"; //Yellow
const BOTTOM_RIGHT = "#80c7ed"; //Blue
const TOP_RIGHT = "#992e2e"; //Red
const NO_DATA = "lightgrey";*/

/*Potential alternative, makes low risk high emissions red
const BOTTOM_LEFT = "#80c7ed"; //Blue
const TOP_LEFT = "#992e2e"; //Red
const BOTTOM_RIGHT = "#f0e784"; //Yellow
const TOP_RIGHT = "#5ca166"; //Green
const NO_DATA = "lightgrey";*/

//Potential alternative, maintains property from above but makes it so that high risk high emissions isn't green
const BOTTOM_LEFT = "#fff1a3"; // Light Pink //Blue
const TOP_LEFT = "#C7003A"; //Red
const BOTTOM_RIGHT = "#d6780d"; //Orange
const TOP_RIGHT = "#900C3E"; // Dark Purple //More Vibrant Yellow
const NO_DATA = "lightgrey";

/*Potential alternative adapted from https://colorbrewer2.org/#type=diverging&scheme=PRGn&n=11
const BOTTOM_LEFT = "grey"; //Grey
const TOP_LEFT = "#40004b"; //Purple
const BOTTOM_RIGHT = "#00441b" //Green
const TOP_RIGHT = "#000000"; //Black
const NO_DATA = "lightgrey";*/

/*Potential alternative adapted from https://colorbrewer2.org/#type=diverging&scheme=BrBG&n=7
const BOTTOM_LEFT = "#b1b1b1"; //Grey
const TOP_LEFT = "#8c510a"; //Brown
const BOTTOM_RIGHT = "#01665e" //Teal
const TOP_RIGHT = "#000000"; //Black
const NO_DATA = "white";*/


//Set up initial state
loadData(2016);
const DisplayType = {
   EMISSIONS: 1,
   GAIN: 2,
   COMBO: 3
};
var display = DisplayType.COMBO;

// Load external data and boot
function loadData(year) {
  d3.queue()
  .defer(d3.json, "js/world.geojson")
  .defer(d3.csv, "ND_GAIN_Data/gain/gain_no_nans.csv", function(d) {  gainData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "Emissions_Data/Emissions_with_ISO3.csv", function(d) { ghgData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "ND_GAIN_Data/gain/gain_rankings.csv", function(d) {  gainRankData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "Emissions_Data/emissions_rankings.csv", function(d) {  ghgRankData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "Emissions_Data/emissions_per_cap_no_nans.csv", function(d) {perCapGhgData.set(d.ISO3, +d[year]); })
  .defer(d3.csv, "Emissions_Data/emissions_per_cap_rankings.csv", function(d) {perCapGhgRankData.set(d.ISO3, +d[year]); })
  .await(ready);
}


function set_up_color_scales() {
  gainColorScale = d3.scaleLinear()
              .domain([20, 76])
              //Right to Left because GAIN index is backwards from risk
              .range([BOTTOM_RIGHT, BOTTOM_LEFT]);
  ghgColorScale =  d3.scaleLinear()
              .domain([-100, 12000])
              .range([BOTTOM_LEFT, TOP_LEFT]);
  perCapGhgColorScale = d3.scaleLinear()
              .domain([0, 35])
              .range([BOTTOM_LEFT, TOP_LEFT]);
}
function ready(error, topo) {
  var projection = d3.geoMercator()
                    .scale(110)
                    .center([0,43])
                    .translate([svg.node().getBoundingClientRect().width / 2, 
                                svg.node().getBoundingClientRect().height / 2]);
  // Background
  svg.select("rect")
      .attr("width", svg.node().getBoundingClientRect().width)
      .attr("height", svg.node().getBoundingClientRect().height);

  // Draw the map
    g.selectAll("path")
    .data(topo.features)
    .enter()
    .append("path")
      // draw each country
      .attr("d", d3.geoPath()
        .projection(projection)
      )
      .on('click', displayVals)
      .style("stroke", "white")
      .style("stroke-width", .25)
      .style("cursor", "pointer")
      // set the color of each country
      set_up_color_scales();
      reload_map();
}
// Function to get Country Values
function displayVals(d, i){
  //Assign Country Name
  d3.select("#country")
    .text(d.properties.name)
  if (per_capita == true){
      gainVal = gainData.get(d.id)
      d3.select("#emissions_tag")
        .text("Emissions (Per Capita), Rank")
      if (typeof gainVal == 'undefined') {
        d3.select("#risk_val")
            .text("No Value")
      } else {
          gainVal = Math.round((gainVal + Number.EPSILON) * 100) / 100
          gainRank = gainRankData.get(d.id)
          d3.select("#risk_val")
            .text(String(gainVal) + ", " + String(gainRank))
      }
      ghgVal = perCapGhgData.get(d.id)
      if (typeof ghgVal == 'undefined') {
        d3.select("#emissions_val")
            .text("No Value")
      } else {
          ghgVal = Math.round((ghgVal + Number.EPSILON) * 100) / 100
          ghgRank = perCapGhgRankData.get(d.id)
          d3.select("#emissions_val")
            .text(String(ghgVal) + ", " + String(ghgRank))
      }
  } else{
      gainVal = gainData.get(d.id)
      d3.select("#emissions_tag")
        .text("Emissions (Total), Rank")
      if (typeof gainVal == 'undefined') {
        d3.select("#risk_val")
            .text("No Value")
      } else {
          gainVal = Math.round((gainVal + Number.EPSILON) * 100) / 100
          gainRank = gainRankData.get(d.id)
          d3.select("#risk_val")
            .text(String(gainVal) + ", " + String(gainRank))
      }
      ghgVal = ghgData.get(d.id)
      if (typeof ghgVal == 'undefined') {
        d3.select("#emissions_val")
            .text("No Value")
      } else {
          ghgVal = Math.round((ghgVal + Number.EPSILON) * 100) / 100
          ghgRank = ghgRankData.get(d.id)
          d3.select("#emissions_val")
            .text(String(ghgVal) + ", " + String(ghgRank))
      }
  }
  
}
// Draw four rectangles and labels for matrix key
svg.append("rect")
    .attr("id", "Min_Each")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 28)
    .attr("y", svg.node().getBoundingClientRect().height *.895)
    .attr("fill", BOTTOM_LEFT)
svg.append("rect")
    .attr("id", "Max_Risk")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 57)
    .attr("y", svg.node().getBoundingClientRect().height *.895)
    .attr("fill", BOTTOM_RIGHT);
svg.append("rect")
    .attr("id", "Max_Emissions")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 28)
    .attr("y", svg.node().getBoundingClientRect().height *.837)
    .attr("fill", TOP_LEFT);
svg.append("rect")
    .attr("id", "Max_Combo")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 57)
    .attr("y", svg.node().getBoundingClientRect().height *.837)
    .attr("fill", TOP_RIGHT);
svg.append("text")
	.style("fill", "black")
	.style("font-family", "monospace")
    .style("font-size", "12px")
    .attr("y", 18)
    .attr("x", 0 - svg.node().getBoundingClientRect().height *.945)
    .attr("text-anchor", "left")
    .attr("transform", "rotate(270)")
    .text("Emissions ->");
svg.append("text")
	.style("fill", "black")
	.style("font-family", "monospace")
    .style("font-size", "12px")
    .attr("x", 28)
    .attr("y", svg.node().getBoundingClientRect().height *.98)
    .attr("text-anchor", "left")
    .text("Risk Index ->");
svg.append("rect")
    .attr("width", 23)
    .attr("height", 23)
    .attr("x", 40)
    .attr("y", svg.node().getBoundingClientRect().height *.70)
    .attr("fill", NO_DATA)
    .style("stroke", NO_DATA)
    .style("stroke-width", 1);
svg.append("text")
  .style("fill", "black")
  .style("font-family", "optima")
    .style("font-size", "12px")
    .attr("x", 51.5)
    .attr("y", svg.node().getBoundingClientRect().height *.79)
    .attr("text-anchor", "middle")
    .text("No Data");

/* TIMELINE START */

var range = [1995, 2016],
    step = 1; // change the step and if null, it'll switch back to a normal slider
// append svg
var timeline_svg = d3.select('#chart');
var width = timeline_svg.node().getBoundingClientRect().width;
var height = timeline_svg.node().getBoundingClientRect().height;

var slider = timeline_svg.append('g')
    .classed('slider', true)
    .attr('transform', 'translate(50, '+ (height * .2) + ')');

// using clamp here to avoid slider exceeding the range limits
var xScale = d3.scaleLinear()
    .domain(range)
    .range([-5, width - 170])
    .clamp(true);

// array useful for step sliders
var rangeValues = d3.range(range[0], range[1], step || 1).concat(range[1]);
var xAxis = d3.axisBottom(xScale).tickValues(rangeValues).tickSize(20).tickFormat(function (d) {
    return d;
});

// drag behavior initialization
var drag = d3.drag()
    .on('start.interrupt', function () {
        slider.interrupt();
    }).on('start drag', function () {
        dragged(d3.event.x);
    });

// this is the main bar with a stroke (applied through CSS)
var track = slider.append('line').attr('class', 'track')
    .attr('x1', xScale.range()[0])
    .attr('x2', xScale.range()[1]);

// this is a bar (steelblue) that's inside the main "track" to make it look like a rect with a border
//var trackInset = d3.select(slider.node().appendChild(track.node().cloneNode())).attr('class', 'track-inset');

var ticks = slider.append('g').attr('class', 'ticks').attr('transform', 'translate(0, -4)')
    .call(xAxis);

d3.selectAll('g.tick') 
  .selectAll("line")//grab the tick line
  .attr('class', 'quadrantBorder') //style with a custom class and CSS
  .style('stroke', "white")
  .style('stroke-width', "3px"); //or style directly with attributes or inline styles

d3.selectAll("g.tick").selectAll("text")
  .each(function(d, i){
    d3.select(this).style("font-family", "monospace");
    d3.select(this).style("font-size", "12px");
    d3.select(this).style("fill", "black");
  });

// drag handle
var handle = slider.append('circle').classed('handle', true)
    .attr('r', 9)

// this is the bar on top of above tracks with stroke = transparent and on which the drag behaviour is actually called
// try removing above 2 tracks and play around with the CSS for this track overlay, you'll see the difference
var trackOverlay = d3.select(slider.node().appendChild(track.node().cloneNode())).attr('class', 'track-overlay')
    .call(drag);

//initial animation - MARGO – I don't know why it speed up in the middle. Will fix later
  slider.transition().duration(7500)
    .tween("drag", function () {
        var i = d3.interpolate(1995, 2016);
        return function (t) {
            dragged(xScale(i(t)));
        };
});

function dragged(value) {
    var x = xScale.invert(value), index = null, midPoint, cx, year;
    if(step) {
        // if step has a value, compute the midpoint based on range values and reposition the slider based on the mouse position
        for (var i = 0; i < rangeValues.length - 1; i++) {
            if (x >= rangeValues[i] && x <= rangeValues[i + 1]) {
                index = i;
                break;
            }
        }
        midPoint = (rangeValues[index] + rangeValues[index + 1]) / 2;
        if (x < midPoint) {
            cx = xScale(rangeValues[index]);
            year = rangeValues[index];
        } else {
            cx = xScale(rangeValues[index + 1]);
            year = rangeValues[index + 1];
        }
    } else {
        // if step is null or 0, return the drag value as is
        cx = xScale(x);
        year = x.toFixed(3);
    }
    // use xVal as drag value
    loadData(year);
    handle.attr('cx', cx);
}

/* TIMELINE END */

var button_svg = d3.select('#toggles'),
    width = +button_svg.node().getBoundingClientRect().width,
    height = +button_svg.node().getBoundingClientRect().height;
var per_capita = false;

var help = d3.select("body").append("div")
                  .attr("class", "tooltip-donut")
                  .style("opacity", 0);
var description = "<p><b>Combination Matrix:</b> Bloop.</p> \
                             <p><b>Emissions:</b> Bloop.</p> \
                             <p><b>Risk Index:</b> Bloop.</p>";

var toggle_title = button_svg.append("g");

toggle_title.append("text")
    .attr("text-anchor", "middle")
    .attr("x", button_svg.node().getBoundingClientRect().width * .45)
    .attr("y", button_svg.node().getBoundingClientRect().height * .1)
    .style("font-family", "optima")
    .text("Map Displays:");

toggle_title.append("circle")
    .attr("cx", button_svg.node().getBoundingClientRect().width * .83)
    .attr("cy", button_svg.node().getBoundingClientRect().height * .08)
    .attr("r", 8)
    .attr("stroke-width","1px")
    .attr("stroke", "black")
    .attr("fill", "white")
    .style("cursor", "pointer")
    .on('click', function (d, i) {
          help.transition()
               .duration(50)
               .style("opacity", 1);
          help.html(description)
               .style("left", (d3.event.pageX + 10) + "px")
               .style("top", (d3.event.pageY - 15) + "px");
     })
     .on('mouseout', function (d, i) {
          help.transition()
               .duration('50')
               .style("opacity", 0);
     });
toggle_title.append("text")
    .attr("x", button_svg.node().getBoundingClientRect().width * .815)
    .attr("y", button_svg.node().getBoundingClientRect().height * .1)
    .style("font-size", "11px")
    .attr("fill", "black")
    .text("?")
    .style("cursor", "pointer")
    .on('click', function (d, i) {
          help.transition()
               .duration(50)
               .style("opacity", 1);
          help.html(description)
               .style("left", (d3.event.pageX + 10) + "px")
               .style("top", (d3.event.pageY - 15) + "px");
     })
     .on('mouseout', function (d, i) {
          help.transition()
               .duration('50')
               .style("opacity", 0);
     });

var combo = button_svg.append("g").attr("class", "button");

combo.append("rect")
    .attr("width", button_svg.node().getBoundingClientRect().width * .85)
    .attr("height", button_svg.node().getBoundingClientRect().height * .18)
    .attr("x", button_svg.node().getBoundingClientRect().width * .1)
    .attr("y", button_svg.node().getBoundingClientRect().height * .2)
    .attr("id", "combo_button")
    .on("click", dispCombo);

combo.append("text")
    .text("Combination Matrix")
    .attr("x", button_svg.node().getBoundingClientRect().width * .24)
    .attr("y", button_svg.node().getBoundingClientRect().height * .31)
    .on("click", dispCombo);

var emissions = button_svg.append("g").attr("class", "button");

emissions.append("rect")
    .attr("width", button_svg.node().getBoundingClientRect().width * .85)
    .attr("height", button_svg.node().getBoundingClientRect().height * .18)
    .attr("x", button_svg.node().getBoundingClientRect().width * .1)
    .attr("y", button_svg.node().getBoundingClientRect().height * .4)
    .attr("id", "emissions_button")
    .on("click", dispEmissions);

emissions.append("text")
    .text("Emissions")
    .attr("x", button_svg.node().getBoundingClientRect().width * .38)
    .attr("y", button_svg.node().getBoundingClientRect().height * .51)
    .on("click", dispEmissions);

var emissions_pop = button_svg.append("g").attr("id", "pop").attr("class", "button_checked");

emissions_pop.append("rect")
    .attr("class", "button_unchecked")
    .attr("id", "pop")
    .attr("width", button_svg.node().getBoundingClientRect().width * .422)
    .attr("height", button_svg.node().getBoundingClientRect().height * .1)
    .attr("x", button_svg.node().getBoundingClientRect().width * .102)
    .attr("y", button_svg.node().getBoundingClientRect().height * .58)
    .on("click", function(d, i) {
      per_capita = false;
      d3.select("#pop").classed("button_unchecked", false);
      d3.select("#pop").classed("button_checked", true);
      d3.select("#cap").classed("button_checked", false);
      d3.select("#cap").classed("button_unchecked", true);
      reload_map();
    });

var textE = emissions_pop.append("text")
            .text("National Total")
            .attr("class", "button_checked")
            .attr("id", "pop")
            .attr("y", button_svg.node().getBoundingClientRect().height * .645)
            .on("click", function(d, i) {
              per_capita = false;
              d3.select("#pop").classed("button_unchecked", false);
              d3.select("#pop").classed("button_checked", true);
              d3.select("#cap").classed("button_checked", false);
              d3.select("#cap").classed("button_unchecked", true);
              reload_map();
            });

var textwidth = d3.select("#pop text").node().getComputedTextLength();
textE.attr("x", ((button_svg.node().getBoundingClientRect().width * .422) - textwidth) / 2 + button_svg.node().getBoundingClientRect().width * .102);

var emissions_cap = button_svg.append("g").attr("id", "cap").attr("class", "button_unchecked");

emissions_cap.append("rect")
    .attr("class", "button_checked")
    .attr("id", "cap")
    .attr("width", button_svg.node().getBoundingClientRect().width * .42)
    .attr("height", button_svg.node().getBoundingClientRect().height * .1)
    .attr("x", button_svg.node().getBoundingClientRect().width * .527)
    .attr("y", button_svg.node().getBoundingClientRect().height * .58)
    .on("click", function(d, i) {
      per_capita = true;
      d3.select("#cap").classed("button_unchecked", false);
      d3.select("#cap").classed("button_checked", true);
      d3.select("#pop").classed("button_checked", false);
      d3.select("#pop").classed("button_unchecked", true);
      reload_map();
    });

textE = emissions_cap.append("text")
    .text("Per Capita")
    .attr("class", "button_unchecked")
    .attr("id", "cap")
    .attr("y", button_svg.node().getBoundingClientRect().height * .645)
    .on("click", function(d, i) {
      per_capita = true;
      d3.select("#cap").classed("button_unchecked", false);
      d3.select("#cap").classed("button_checked", true);
      d3.select("#pop").classed("button_checked", false);
      d3.select("#pop").classed("button_unchecked", true);
      reload_map();
    });

textwidth = d3.select("#cap text").node().getComputedTextLength();
textE.attr("x", ((button_svg.node().getBoundingClientRect().width * .42) - textwidth) / 2 + button_svg.node().getBoundingClientRect().width * .527);

var risk = button_svg.append("g").attr("class", "button");

risk.append("rect")
    .attr("width", button_svg.node().getBoundingClientRect().width * .85)
    .attr("height", button_svg.node().getBoundingClientRect().height * .18)
    .attr("x", button_svg.node().getBoundingClientRect().width * .1)
    .attr("y", button_svg.node().getBoundingClientRect().height * .70)
    .attr("id", "risk_button")
    .on("click", dispGain);

risk.append("text")
    .text("Risk Index")
    .attr("x", button_svg.node().getBoundingClientRect().width * .35)
    .attr("y", button_svg.node().getBoundingClientRect().height * .81)
    .on("click", dispGain);


//Experimenting with info window
var info_window_svg = d3.select("#infowindow")
    width = +info_window_svg.node().getBoundingClientRect().width,
    height = +info_window_svg.node().getBoundingClientRect().height + 20;

info_window_svg.append("rect")
  .attr("class", "toggles_background")
  .attr("width", 175)
  .attr("height", 180)

// Info Window Text Objects
info_window_svg.append("text")
                .attr("id", "country")
                .attr("text-anchor", "middle")
                .attr("x", info_window_svg.node().getBoundingClientRect().width * .40)
                .attr("y", info_window_svg.node().getBoundingClientRect().height * 0.1)
                .style("font-family", "optima")
                .style("font-weight", "bold")
                .text("Country Name");
info_window_svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", info_window_svg.node().getBoundingClientRect().width * .40)
                .attr("y", info_window_svg.node().getBoundingClientRect().height * .225)
                .style("font-family", "optima")
                .text("Risk Index, Rank");
info_window_svg.append("text")
                .attr("id", "risk_val")
                .attr("text-anchor", "middle")
                .attr("x", info_window_svg.node().getBoundingClientRect().width * .40)
                .attr("y", info_window_svg.node().getBoundingClientRect().height * .35)
                .style("font-family", "optima")
                .text("Click on Country");

info_window_svg.append("text")
                .attr("id", "emissions_tag")
                .attr("text-anchor", "middle")
                .attr("x", info_window_svg.node().getBoundingClientRect().width * .40)
                .attr("y", info_window_svg.node().getBoundingClientRect().height * .475)
                .style("font-family", "optima")
                .text("Emissions (Total), Rank");

info_window_svg.append("text")
                .attr("id", "emissions_val")
                .attr("text-anchor", "middle")
                .attr("x", info_window_svg.node().getBoundingClientRect().width * .40)
                .attr("y", info_window_svg.node().getBoundingClientRect().height * .6)
                .style("font-family", "optima")
                .text("Click on Country");





  // Zoom map upon mouse zoom
function zoomed() {
  g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  g.attr("transform", d3.event.transform);
}

function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

function average(array) {
  return array.reduce((a, b) => a + b) / array.length;
}

function fillCountryColor() {
  displayPerCap = per_capita;
  var ghgMidpoint = average(ghgData.values());
  var gainMidpoint = average(gainData.values());
  var perCapMidpoint = average(perCapGhgData.values());
  g.selectAll("path")
    .attr("fill", function (d) {

          ghgVal = ghgData.get(d.id);
          gainVal = gainData.get(d.id);
          perCapGhgVal = perCapGhgData.get(d.id);
          ghgDisplayVal = displayPerCap ? perCapGhgVal : ghgVal; 

          ghgDisplayMidpoint = displayPerCap ? perCapMidpoint : ghgMidpoint

          if (typeof ghgDisplayVal == 'undefined' || typeof gainVal == 'undefined') {
            return NO_DATA;
          } else if (ghgDisplayVal <= ghgDisplayMidpoint && gainVal >= gainMidpoint) {
            return BOTTOM_LEFT;
          } else if (ghgDisplayVal > ghgDisplayMidpoint && gainVal >= gainMidpoint) {
            return TOP_LEFT;
          } else if (ghgDisplayVal <= ghgDisplayMidpoint && gainVal < gainMidpoint) {
            return BOTTOM_RIGHT;
          } else if (ghgDisplayVal > ghgDisplayMidpoint && gainVal < gainMidpoint) {
            return TOP_RIGHT;
          } else {
            return "black";
          }
        })
}
function fillGainColor() {
  var gainMidpoint = average(gainData.values());
  g.selectAll("path")
    .attr("fill", function (d) {
          if (typeof gainData.get(d.id) == 'undefined') {
            return NO_DATA;
          } else {
            return gainColorScale(gainData.get(d.id));
          }
        })
}
function fillEmissionsColor() {
  displayPerCap = per_capita;
  g.selectAll("path")
    .attr("fill", function (d) {
          ghgVal = ghgData.get(d.id);
          perCapGhgVal = perCapGhgData.get(d.id);
          ghgDisplayVal = displayPerCap ? perCapGhgVal : ghgVal ;
          ghgDisplayColorScale = displayPerCap ? perCapGhgColorScale : ghgColorScale;
          if (typeof ghgDisplayVal == 'undefined') {
            return NO_DATA;
          } else {
            return ghgDisplayColorScale(ghgDisplayVal);
          }
        })
}


function dispGain(){
    display = DisplayType.GAIN;
    var maxRisk = d3.select('#Max_Risk')
                  .attr('opacity', 100)
    var maxCombo = d3.select('#Max_Combo')
                  .attr('opacity', 0)
    var maxEmissions = d3.select('#Max_Emissions')
                          .attr('opacity', 0)
    reload_map();
}
function dispEmissions(){
    display = DisplayType.EMISSIONS;
    var maxRisk = d3.select('#Max_Risk')
                  .attr('opacity', 0)
    var maxCombo = d3.select('#Max_Combo')
                  .attr('opacity', 0)
    var maxEmissions = d3.select('#Max_Emissions')
                          .attr('opacity', 100)
    reload_map();
}

function dispCombo(){
    display = DisplayType.COMBO;
    var maxRisk = d3.select('#Max_Risk')
                  .attr('opacity', 100)
    var maxCombo = d3.select('#Max_Combo')
                  .attr('opacity', 100)
    var maxEmissions = d3.select('#Max_Emissions')
                          .attr('opacity', 100)
    reload_map();
}

function reload_map() {
    switch (display) {
      case DisplayType.EMISSIONS:
        fillEmissionsColor();
        break;
      case DisplayType.GAIN:
        fillGainColor();
        break;
      case DisplayType.COMBO:
        fillCountryColor()
    }
}


// Determine color of country
function valuesToColor(ghgVal, gainVal) {
  // Specific to 2016 though... 

}

/* Bar Chart Stuff

var bar_chart_svg = d3.select("#barchart")
    width = +info_window_svg.node().getBoundingClientRect().width,
    height = +info_window_svg.node().getBoundingClientRect().height;

var margin = {top: 20, right: 20, bottom: 70, left: 40},
    width = 600 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;

bar_chart_svg.append("g")
              .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

var x = d3.scale.ordinal().rangeRoundBands([0, width], .05);

var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .tickFormat(d3.time.format("%Y-%m"));

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(10);

d3.csv("bar-data.csv", function(error, data) {

    data.forEach(function(d) {
        d.date = parseDate(d.date);
        d.value = +d.value;
    });
  
  x.domain(data.map(function(d) { return d.date; }));
  y.domain([0, d3.max(data, function(d) { return d.value; })]);

  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis)
    .selectAll("text")
      .style("text-anchor", "end")
      .attr("dx", "-.8em")
      .attr("dy", "-.55em")
      .attr("transform", "rotate(-90)" );

  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Value ($)");

  svg.selectAll("bar")
      .data(data)
    .enter().append("rect")
      .style("fill", "steelblue")
      .attr("x", function(d) { return x(d.date); })
      .attr("width", x.rangeBand())
      .attr("y", function(d) { return y(d.value); })
      .attr("height", function(d) { return height - y(d.value); });

});
*/

</script>
</body>








